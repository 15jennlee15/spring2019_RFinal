---
title: "Model Comparisons with map2"
description: |
  This tutorial will take you through how to conduct multiple comparisons using map2.
author:
  - name: Kathryn Denning
date: 06-04-2019
output:
  distill::distill_article:
    self_contained: false
---

```{r setup and code from other tutorial sections, include = FALSE}
library(tidyverse)
library(rio)
library(here)
library(stringr)
#install.packages("splitstackshape")
library(splitstackshape)
library(magrittr)
library(glue)

options(scipen=999)

# All data from Jenn's and Tamara's tutorial that were needed to get to the point that I can run my code
data <- import(here("data", "movie_metadata.csv_movie_metadata.csv"))

data <- data %>%
  mutate(gross = as.numeric(gross),
         budget = as.numeric(budget),
         profit = gross-budget)

df_genre <- data %>% 
  drop_na()%>%
  group_by(genres)%>%
  nest()

data_new <- data%>%
 drop_na() %>%
 filter(movie_facebook_likes != "0")

data_new<- cSplit(data_new, "genres", "|")

data_new %<>% rename(main_genre = genres_1)

df_main_genre <- data_new%>%
 select(-genres_2:-genres_8) %>%
 filter(!grepl('Thriller|Western|Musical|Family|Romance|Sci-Fi', main_genre)) %>%
# need to remove thriller, western, musical, family, romance, sci_fi for having less than 5 movies
 group_by(main_genre) %>%
 nest()

df_mg_nonull <- df_main_genre[[2]]
df_mg_nonull <- df_mg_nonull[!map_lgl(df_mg_nonull, is.null)]

df_mg_list <- data_new %>%
 select(-genres_2, -genres_3, -genres_4, -genres_5, -genres_6, -genres_7, -genres_8)%>%
 mutate(main_genre = as.factor(main_genre)) %>%
 filter(!grepl('Thriller|Western|Musical|Family|Romance|Sci-Fi', main_genre)) %>%
 droplevels(data_new$main_genre) %>%
# need to remove thriller, western, musical, family, romance, sci_fi for having less than 5 movies
   as_tibble()


by_main_genre <- split(df_mg_list, df_mg_list$main_genre)
```

You just learned in the previous tutorial how to use map to run the same linear regression repeatedly for different genres of the dataset and extract information (like the coefficients) from the dataset. However, what if you wanted to run a model comparison, meaning you wanted to cycle through the data twice using two different models? 

To do this, you'll need to use map2! Unlike map and its variants (e.g., map_dbl, map_df) that only allow you to provide one input, map2 allows for the user to provide two inputs, or two things you want it to cycle through. But why is this useful? Lets check out why we need it by looking at some code.

As a reminder, this was the final output from the last tutorial where you ran one multiple comparison and extracted its output using map.

```{r review of when we used map}
model <- map(by_main_genre, ~lm(profit ~ movie_facebook_likes, .x))

coefs <- map(model, ~coef(.x))
coefs

slopes <- map_dbl(coefs, 2)
slopes
```

# compare model 1 vs model 2, model 2 adds a second predictor (imbd score) to see if there is a better fit
## this is just showing the second model as an example for the tutorial

If we wanted to add a second predictor and run another regression with that second predictor of IMBD Score, we could do that using map.

```{r second model using map}
model2 <- map(by_main_genre, ~lm(profit ~ movie_facebook_likes + imdb_score, .x))
```

However, we can't run a typical model comparison of the output of these two models using anova because we can an error that anova can not be applied to an object of class "list."

```{r, error = TRUE}
anova(model, model2)
```

Why can't we do this? Well, we don't just have two linear regressions overall, we have two separate lists of two types of linear regressions that were run on eleven different genres (22 regression overall!). We need to compare model 1 and model 2 for each genre, and to do this, we are going to need to combine the lists by nesting them into one dataframe and then use map2 to cycle through the lists of model output. 

How we combine our two dataframes into...
# Get our two models into a tibble that we can then compare the models and plot

```{r}
model_comparison_df <- by_main_genre %>% 
  bind_rows(.id = "genre") %>% #for tutorial, make note on what this does and why you have to do it to use group-by
  group_by(genre) %>% 
  na.omit() %>% 
  nest() %>% 
  mutate(m1 = map(data, ~lm(profit ~ movie_facebook_likes, .x)),
         m2 = map(data, ~lm(profit ~ movie_facebook_likes + imdb_score, .x)))
  

model_comparison_df$m1[[1]]

#model comparison 
compare_modelfit <- anova(model_comparison_df$m1[[1]], model_comparison_df$m2[[1]])

# putting the model comparison into a dataset that has extracted the p-value
## This is where you use map2 to loop through each of the model lists and compare them with Anova
compare_all <- model_comparison_df %>%
    mutate(anova_output = map2(m1, m2, anova),
           p_val = map_dbl(anova_output, list("Pr(>F)", 2)))

# tidying the data so that we have the models in long-format and extracting r-square for each model as its own column
compare_all_tidy <- compare_all %>% 
  gather(model, output, m1:m2) %>% 
  mutate(r_square = map_dbl(output, ~summary(.x)$r.squared))

```

Now that we have our data in tidy format we can plot the r-square for each model by Genre.
We use model (model 1 and 2) as our x axis and r-square on the y-axis. We can use facet-wrap
to create a plot for each genre side by side. We aren't going to worry about making it look pretty right now, we just want to get an idea of what it looks like. For example, it looks like our model fits well for Animation and Documentaries, but not so well for Action, Comedy, Crime. 
